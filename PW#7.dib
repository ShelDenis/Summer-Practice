#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System.Threading;
using System.Collections.Concurrent;

static bool exit = false;
static bool soft_exit = false;
private static ManualResetEvent mre = new ManualResetEvent(false);

class ServerThread
{
    List<Task> tlist = new List<Task>();

    public void ExceptionHandler(ICommand com, Exception exc)
    {
        Console.WriteLine("Ошибка!");
    }

    public void new_thread(ConcurrentQueue<ICommand> queue)
    {
        Task t = Task.Run(() => 
        {
            bool soft_stop = false;
            while (true)
            {
                ICommand c;
                bool ok = queue.TryDequeue(out c);
                if (ok)
                {
                    try
                    {
                        mre.WaitOne();
                        mre.Reset();
                        c.Execute();
                        if (exit)
                        {
                            exit = false;
                            mre.Set();
                            break;
                        }
                        if (soft_exit || soft_stop)
                        {
                            soft_stop = true;
                            if (queue.Count == 0)
                            {
                                Console.WriteLine("Плавный выход");
                                mre.Set();
                                break;
                            }
                            soft_exit = false;
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionHandler(c, e);
                    }
                    mre.Set();
                }
            }
        });
        tlist.Add(t);
    }

    public void green_light()
    {
        Task[] tarr = tlist.ToArray();
        Task.WaitAll(tarr);
    }
}

class HardStop: ICommand
{
    public void Execute()
    {
        Console.WriteLine("Резкий выход");
        exit = true;
    }
}


class SoftStop: ICommand
{
    public void Execute()
    {
        soft_exit = true;
    }
}


class SimpleCommand: ICommand
{
    public void Execute()
    {
        Console.WriteLine("(1) Команда выполнилась");
    }
}

class SimpleCommand2: ICommand
{
    public void Execute()
    {
        Console.WriteLine("(2) Команда выполнилась");
    }
}

class SimpleCommand3: ICommand
{
    public void Execute()
    {
        Console.WriteLine("(3) Команда выполнилась");
    }
}

class TestCommand: ICommand
{
    public void Execute()
    {
        Console.WriteLine("Неудача!");
    }
}


ServerThread server = new ServerThread();

ICommand[] lst1 = 
{
    new SimpleCommand(),
    new SimpleCommand(),
    new SoftStop(),
};

ICommand[] lst2 = 
{
    new SimpleCommand2(),
    new SoftStop(),
    new SimpleCommand2(),
};

ICommand[] lst3 = 
{
    new SimpleCommand3(),
    new SimpleCommand3(),
    new HardStop(),
    new TestCommand()
};

// Тест

ServerThread s = new ServerThread();

ConcurrentQueue<ICommand> user1 = new ConcurrentQueue<ICommand>();
foreach(ICommand ic in lst1) user1.Enqueue(ic);
ConcurrentQueue<ICommand> user2 = new ConcurrentQueue<ICommand>();
foreach(ICommand ic in lst2) user2.Enqueue(ic);
ConcurrentQueue<ICommand> user3 = new ConcurrentQueue<ICommand>();
foreach(ICommand ic in lst3) user3.Enqueue(ic);

mre.Set();
s.new_thread(user1);
s.new_thread(user2);
s.new_thread(user3);
s.green_light();

// Заметим, что в первом потоке выполнились 2 команды, в конце очереди стоял SoftStop => поток завершился
// Второй поток закончил свое выполнение только после опустошения очереди (SoftStop стоял в середине очереди)
// Третий поток остановился сразу после HardStop, несмотря на то, что в очереди еще осталась одна команда.

#!markdown

Заметим, что в первом потоке выполнились 2 команды, в конце очереди стоял SoftStop => поток завершился

Второй поток закончил свое выполнение только после опустошения очереди (SoftStop стоял в середине очереди)

Третий поток остановился сразу после HardStop, несмотря на то, что в очереди еще осталась одна команда.
